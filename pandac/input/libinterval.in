1145555763
2 2
11 libinterval 4 SpsC 6 direct 
116
125 8 get_name 4 241 19 CInterval::get_name 0 1 1 920
// Filename: cInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) 2001 - 2004, Disney Enterprises, Inc.  All rights reserved
//
// All use of this software is subject to the terms of the Panda 3d
// Software license.  You should have received a copy of this license
// along with this source code; you will also find a current copy of
// the license at http://etc.cmu.edu/panda3d/docs/license/ .
//
// To contact the maintainers of this program write to
// panda3d-general@lists.sourceforge.net .
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_name
//       Access: Published
//  Description: Returns the interval's name.
////////////////////////////////////////////////////////////////////
67
inline basic_string< char > const &CInterval::get_name(void) const;

126 12 get_duration 4 241 23 CInterval::get_duration 0 1 2 271
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_duration
//       Access: Published
//  Description: Returns the duration of the interval in seconds.
////////////////////////////////////////////////////////////////////
50
inline double CInterval::get_duration(void) const;

127 14 get_open_ended 4 241 25 CInterval::get_open_ended 0 1 3 685
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_open_ended
//       Access: Published
//  Description: Returns the state of the "open_ended" flag.  This is
//               primarily intended for instantaneous intervals like
//               FunctionIntervals; it indicates true if the interval
//               has some lasting effect that should be applied even
//               if the interval doesn't get started until after its
//               finish time, or false if the interval is a transitive
//               thing that doesn't need to be called late.
////////////////////////////////////////////////////////////////////
50
inline bool CInterval::get_open_ended(void) const;

128 9 get_state 4 241 20 CInterval::get_state 0 1 4 385
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_state
//       Access: Published
//  Description: Indicates the state the interval believes it is in:
//               whether it has been started, is currently in the
//               middle, or has been finalized.
////////////////////////////////////////////////////////////////////
57
inline CInterval::State CInterval::get_state(void) const;

129 10 is_stopped 4 241 21 CInterval::is_stopped 0 1 5 364
////////////////////////////////////////////////////////////////////
//     Function: CInterval::is_stopped
//       Access: Published
//  Description: Returns true if the interval is in either its initial
//               or final states (but not in a running or paused
//               state).
////////////////////////////////////////////////////////////////////
46
inline bool CInterval::is_stopped(void) const;

130 14 set_done_event 4 241 25 CInterval::set_done_event 0 1 6 426
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_done_event
//       Access: Published
//  Description: Sets the event that is generated whenever the
//               interval reaches its final state, whether it is
//               explicitly finished or whether it gets there on its
//               own.
////////////////////////////////////////////////////////////////////
73
inline void CInterval::set_done_event(basic_string< char > const &event);

131 14 get_done_event 4 241 25 CInterval::get_done_event 0 1 7 429
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_done_event
//       Access: Published
//  Description: Returns the event that is generated whenever the
//               interval reaches its final state, whether it is
//               explicitly finished or whether it gets there on its
//               own.
////////////////////////////////////////////////////////////////////
73
inline basic_string< char > const &CInterval::get_done_event(void) const;

132 5 set_t 4 241 16 CInterval::set_t 0 1 8 450
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_t
//       Access: Published
//  Description: Explicitly sets the time within the interval.
//               Normally, you would use start() .. finish() to let
//               the time play normally, but this may be used to set
//               the time to some particular value.
////////////////////////////////////////////////////////////////////
32
void CInterval::set_t(double t);

133 5 get_t 4 241 16 CInterval::get_t 0 1 9 373
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_t
//       Access: Published
//  Description: Returns the current time of the interval: the last
//               value of t passed to priv_initialize(), priv_step(), or
//               priv_finalize().
////////////////////////////////////////////////////////////////////
43
inline double CInterval::get_t(void) const;

134 14 set_auto_pause 4 241 25 CInterval::set_auto_pause 0 1 10 624
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_auto_pause
//       Access: Published
//  Description: Changes the state of the 'auto_pause' flag.  If
//               this is true, the interval may be arbitrarily
//               interrupted when the system needs to reset due to
//               some external event by calling
//               CIntervalManager::interrupt().  If this
//               is false (the default), the interval must always be
//               explicitly finished or paused.
////////////////////////////////////////////////////////////////////
55
inline void CInterval::set_auto_pause(bool auto_pause);

135 14 get_auto_pause 4 241 25 CInterval::get_auto_pause 0 1 11 308
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_auto_pause
//       Access: Published
//  Description: Returns the state of the 'auto_pause' flag.  See
//               set_auto_pause().
////////////////////////////////////////////////////////////////////
50
inline bool CInterval::get_auto_pause(void) const;

136 15 set_auto_finish 4 241 26 CInterval::set_auto_finish 0 1 12 623
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_auto_finish
//       Access: Published
//  Description: Changes the state of the 'auto_finish' flag.  If
//               this is true, the interval may be arbitrarily
//               finished when the system needs to reset due to
//               some external event by calling
//               CIntervalManager::interrupt().  If this
//               is false (the default), the interval must always be
//               explicitly finished or paused.
////////////////////////////////////////////////////////////////////
57
inline void CInterval::set_auto_finish(bool auto_finish);

137 15 get_auto_finish 4 241 26 CInterval::get_auto_finish 0 1 13 311
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_auto_finish
//       Access: Published
//  Description: Returns the state of the 'auto_finish' flag.  See
//               set_auto_finish().
////////////////////////////////////////////////////////////////////
51
inline bool CInterval::get_auto_finish(void) const;

138 20 set_wants_t_callback 4 241 31 CInterval::set_wants_t_callback 0 1 14 533
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_wants_t_callback
//       Access: Published
//  Description: Changes the state of the 'wants_t_callback' flag.  If
//               this is true, the interval will be returned by
//               CIntervalManager::get_event() each time the
//               interval's time value has been changed, regardless of
//               whether it has any external events.
////////////////////////////////////////////////////////////////////
67
inline void CInterval::set_wants_t_callback(bool wants_t_callback);

139 20 get_wants_t_callback 4 241 31 CInterval::get_wants_t_callback 0 1 15 325
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_wants_t_callback
//       Access: Published
//  Description: Returns the state of the 'wants_t_callback' flag.
//               See set_wants_t_callback().
////////////////////////////////////////////////////////////////////
56
inline bool CInterval::get_wants_t_callback(void) const;

140 11 set_manager 4 241 22 CInterval::set_manager 0 1 16 523
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_manager
//       Access: Published
//  Description: Indicates the CIntervalManager object which will be
//               responsible for playing this interval.  This defaults
//               to the global CIntervalManager; you should need to
//               change this only if you have special requirements for
//               playing this interval.
////////////////////////////////////////////////////////////////////
62
inline void CInterval::set_manager(CIntervalManager *manager);

141 11 get_manager 4 241 22 CInterval::get_manager 0 1 17 604
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_manager
//       Access: Published
//  Description: Returns the CIntervalManager object which will be
//               responsible for playing this interval.  Note that
//               this can only return a C++ object; if the particular
//               CIntervalManager object has been extended in the
//               scripting language, this will return the encapsulated
//               C++ object, not the full extended object.
////////////////////////////////////////////////////////////////////
60
inline CIntervalManager *CInterval::get_manager(void) const;

142 5 start 4 241 16 CInterval::start 0 4 18 19 20 21 478
////////////////////////////////////////////////////////////////////
//     Function: CInterval::start
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play to the end and stop.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
////////////////////////////////////////////////////////////////////
89
void CInterval::start(double start_t = (0), double end_t = (-1), double play_rate = (1));

143 4 loop 4 241 15 CInterval::loop 0 4 22 23 24 25 587
////////////////////////////////////////////////////////////////////
//     Function: CInterval::loop
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play until it is interrupted with finish() or
//               pause(), looping back to start_t when it reaches
//               end_t.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
////////////////////////////////////////////////////////////////////
88
void CInterval::loop(double start_t = (0), double end_t = (-1), double play_rate = (1));

144 5 pause 4 241 16 CInterval::pause 0 1 26 379
////////////////////////////////////////////////////////////////////
//     Function: CInterval::pause
//       Access: Published
//  Description: Stops the interval from playing but leaves it in its
//               current state.  It may later be resumed from this
//               point by calling resume().
////////////////////////////////////////////////////////////////////
30
double CInterval::pause(void);

145 6 resume 4 241 17 CInterval::resume 0 2 27 28 628
////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume
//       Access: Published
//  Description: Restarts the interval from its current point after a
//               previous call to pause().
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume
//       Access: Published
//  Description: Restarts the interval from the indicated point after a
//               previous call to pause().
////////////////////////////////////////////////////////////////////
29
void CInterval::resume(void);

146 12 resume_until 4 241 23 CInterval::resume_until 0 1 29 440
////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume_until
//       Access: Published
//  Description: Restarts the interval from the current point after a
//               previous call to pause() (or a previous
//               play-to-point-and-stop), to play until the indicated
//               point and then stop.
////////////////////////////////////////////////////////////////////
43
void CInterval::resume_until(double end_t);

147 6 finish 4 241 17 CInterval::finish 0 1 30 297
////////////////////////////////////////////////////////////////////
//     Function: CInterval::finish
//       Access: Published
//  Description: Stops the interval from playing and sets it to its
//               final state.
////////////////////////////////////////////////////////////////////
29
void CInterval::finish(void);

148 16 clear_to_initial 4 241 27 CInterval::clear_to_initial 0 1 31 551
////////////////////////////////////////////////////////////////////
//     Function: CInterval::clear_to_initial
//       Access: Published
//  Description: Pauses the interval, if it is playing, and resets its
//               state to its initial state, abandoning any state
//               changes already in progress in the middle of the
//               interval.  Calling this is like pausing the interval
//               and discarding it, creating a new one in its place.
////////////////////////////////////////////////////////////////////
39
void CInterval::clear_to_initial(void);

149 10 is_playing 4 241 21 CInterval::is_playing 0 1 32 305
////////////////////////////////////////////////////////////////////
//     Function: CInterval::is_playing
//       Access: Published
//  Description: Returns true if the interval is currently playing,
//               false otherwise.
////////////////////////////////////////////////////////////////////
39
bool CInterval::is_playing(void) const;

150 13 priv_do_event 4 241 24 CInterval::priv_do_event 0 1 33 709
// These functions control the actual playback of the interval.
// Don't call them directly; they're intended to be called from a
// supervising object, e.g. the Python start() .. finish()
// interface.
// These cannot be declared private because they must be accessible
// to Python, but the method names are prefixed with priv_ to remind
// you that you probably don't want to be using them directly.

////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_do_event
//       Access: Published
//  Description: Calls the appropriate event function indicated by the
//               EventType.
////////////////////////////////////////////////////////////////////
68
void CInterval::priv_do_event(double t, CInterval::EventType event);

151 15 priv_initialize 4 241 26 CInterval::priv_initialize 0 1 34 889
// These functions control the actual playback of the interval.
// Don't call them directly; they're intended to be called from a
// supervising object, e.g. the Python start() .. finish()
// interface.
// These cannot be declared private because they must be accessible
// to Python, but the method names are prefixed with priv_ to remind
// you that you probably don't want to be using them directly.

////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_initialize
//       Access: Published, Virtual
//  Description: This replaces the first call to priv_step(), and indicates
//               that the interval has just begun.  This may be
//               overridden by derived classes that need to do some
//               explicit initialization on the first call.
////////////////////////////////////////////////////////////////////
50
virtual void CInterval::priv_initialize(double t);

152 12 priv_instant 4 241 23 CInterval::priv_instant 0 1 35 486
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_instant
//       Access: Published, Virtual
//  Description: This is called in lieu of priv_initialize() .. priv_step()
//               .. priv_finalize(), when everything is to happen within
//               one frame.  The interval should initialize itself,
//               then leave itself in the final state.
////////////////////////////////////////////////////////////////////
43
virtual void CInterval::priv_instant(void);

153 9 priv_step 4 241 20 CInterval::priv_step 0 1 36 409
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_step
//       Access: Published, Virtual
//  Description: Advances the time on the interval.  The time may
//               either increase (the normal case) or decrease
//               (e.g. if the interval is being played by a slider).
////////////////////////////////////////////////////////////////////
44
virtual void CInterval::priv_step(double t);

154 13 priv_finalize 4 241 24 CInterval::priv_finalize 0 1 37 439
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_finalize
//       Access: Published, Virtual
//  Description: This is called to stop an interval, forcing it to
//               whatever state it would be after it played all the
//               way through.  It's generally invoked by
//               set_final_t().
////////////////////////////////////////////////////////////////////
44
virtual void CInterval::priv_finalize(void);

155 23 priv_reverse_initialize 4 241 34 CInterval::priv_reverse_initialize 0 1 38 485
////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_initialize
//       Access: Published, Virtual
//  Description: Similar to priv_initialize(), but this is called when the
//               interval is being played backwards; it indicates that
//               the interval should start at the finishing state and
//               undo any intervening intervals.
////////////////////////////////////////////////////////////////////
58
virtual void CInterval::priv_reverse_initialize(double t);

156 20 priv_reverse_instant 4 241 31 CInterval::priv_reverse_instant 0 1 39 524
////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_instant
//       Access: Published, Virtual
//  Description: This is called in lieu of priv_reverse_initialize()
//               .. priv_step() .. priv_reverse_finalize(), when everything is
//               to happen within one frame.  The interval should
//               initialize itself, then leave itself in the initial
//               state.
////////////////////////////////////////////////////////////////////
51
virtual void CInterval::priv_reverse_instant(void);

157 21 priv_reverse_finalize 4 241 32 CInterval::priv_reverse_finalize 0 1 40 393
////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_finalize
//       Access: Published, Virtual
//  Description: Called generally following a priv_reverse_initialize(),
//               this indicates the interval should set itself to the
//               initial state.
////////////////////////////////////////////////////////////////////
52
virtual void CInterval::priv_reverse_finalize(void);

158 14 priv_interrupt 4 241 25 CInterval::priv_interrupt 0 1 41 812
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_interrupt
//       Access: Published, Virtual
//  Description: This is called while the interval is playing to
//               indicate that it is about to be interrupted; that is,
//               priv_step() will not be called for a length of time.  But
//               the interval should remain in its current state in
//               anticipation of being eventually restarted when the
//               calls to priv_step() eventually resume.
//
//               The purpose of this function is to allow self-running
//               intervals like sound intervals to stop the actual
//               sound playback during the pause.
////////////////////////////////////////////////////////////////////
45
virtual void CInterval::priv_interrupt(void);

159 6 output 4 241 17 CInterval::output 0 1 42 226
////////////////////////////////////////////////////////////////////
//     Function: CInterval::output
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
51
virtual void CInterval::output(ostream &out) const;

160 5 write 4 241 16 CInterval::write 0 1 43 225
////////////////////////////////////////////////////////////////////
//     Function: CInterval::write
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
68
virtual void CInterval::write(ostream &out, int indent_level) const;

161 10 setup_play 4 241 21 CInterval::setup_play 0 1 44 831
////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_play
//       Access: Published
//  Description: Called to prepare the interval for automatic timed
//               playback, e.g. via a Python task.  The interval will
//               be played from start_t to end_t, at a time factor
//               specified by play_rate.  start_t must always be less
//               than end_t (except for the exception for end_t == -1,
//               below), but if play_rate is negative the interval
//               will be played backwards.
//
//               Specify end_t of -1 to play the entire interval from
//               start_t.
//
//               Call step_play() repeatedly to execute the interval.
////////////////////////////////////////////////////////////////////
95
void CInterval::setup_play(double start_time, double end_time, double play_rate, bool do_loop);

162 12 setup_resume 4 241 23 CInterval::setup_resume 0 1 45 366
////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_resume
//       Access: Published
//  Description: Called to prepare the interval for restarting at the
//               current point within the interval after an
//               interruption.
////////////////////////////////////////////////////////////////////
35
void CInterval::setup_resume(void);

163 18 setup_resume_until 4 241 29 CInterval::setup_resume_until 0 1 46 470
////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_resume_until
//       Access: Published
//  Description: Called to prepare the interval for restarting from
//               the current point after a previous call to pause()
//               (or a previous play-to-point-and-stop), to play until
//               the indicated point and then stop.
////////////////////////////////////////////////////////////////////
49
void CInterval::setup_resume_until(double end_t);

164 9 step_play 4 241 20 CInterval::step_play 0 1 47 453
////////////////////////////////////////////////////////////////////
//     Function: CInterval::step_play
//       Access: Published
//  Description: Should be called once per frame to execute the
//               automatic timed playback begun with setup_play().
//
//               Returns true if the interval should continue, false
//               if it is done and should stop.
////////////////////////////////////////////////////////////////////
32
bool CInterval::step_play(void);

165 14 get_class_type 4 241 25 CInterval::get_class_type 0 1 48 0
50
static TypeHandle CInterval::get_class_type(void);

166 16 CIntervalManager 4 245 34 CIntervalManager::CIntervalManager 0 1 49 229
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
41
CIntervalManager::CIntervalManager(void);

167 17 ~CIntervalManager 4 245 35 CIntervalManager::~CIntervalManager 0 0 228
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::Destructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
42
CIntervalManager::~CIntervalManager(void);

168 15 set_event_queue 4 245 33 CIntervalManager::set_event_queue 0 1 50 1383
// Filename: cIntervalManager.I
// Created by:  drose (10Sep02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) 2001 - 2004, Disney Enterprises, Inc.  All rights reserved
//
// All use of this software is subject to the terms of the Panda 3d
// Software license.  You should have received a copy of this license
// along with this source code; you will also find a current copy of
// the license at http://etc.cmu.edu/panda3d/docs/license/ .
//
// To contact the maintainers of this program write to
// panda3d-general@lists.sourceforge.net .
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::set_event_queue
//       Access: Published
//  Description: Specifies a custom event queue to be used for
//               throwing done events from intervals as they finish.
//               If this is not specified, the global event queue is
//               used.
//
//               The caller maintains ownership of the EventQueue
//               object; it is the caller's responsibility to ensure
//               that the supplied EventQueue does not destruct during
//               the lifetime of the CIntervalManager.
////////////////////////////////////////////////////////////////////
71
inline void CIntervalManager::set_event_queue(EventQueue *event_queue);

169 15 get_event_queue 4 245 33 CIntervalManager::get_event_queue 0 1 51 347
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_event_queue
//       Access: Published
//  Description: Returns the custom event queue to be used for
//               throwing done events from intervals as they finish.
////////////////////////////////////////////////////////////////////
65
inline EventQueue *CIntervalManager::get_event_queue(void) const;

170 14 add_c_interval 4 245 32 CIntervalManager::add_c_interval 0 1 52 1079
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::add_c_interval
//       Access: Published
//  Description: Adds the interval to the manager, and returns a
//               unique index for the interval.  This index will be
//               unique among all the currently added intervals, but
//               not unique across all intervals ever added to the
//               manager.  The maximum index value will never exceed
//               the maximum number of intervals added at any given
//               time.
//
//               If the external flag is true, the interval is
//               understood to also be stored in the scripting
//               language data structures.  In this case, it will be
//               available for information returned by
//               get_next_event() and get_next_removal().  If external
//               is false, the interval's index will never be returned
//               by these two functions.
////////////////////////////////////////////////////////////////////
73
int CIntervalManager::add_c_interval(CInterval *interval, bool external);

171 15 find_c_interval 4 245 33 CIntervalManager::find_c_interval 0 1 53 356
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::find_c_interval
//       Access: Published
//  Description: Returns the index associated with the named interval,
//               if there is such an interval, or -1 if there is not.
////////////////////////////////////////////////////////////////////
78
int CIntervalManager::find_c_interval(basic_string< char > const &name) const;

172 14 get_c_interval 4 245 32 CIntervalManager::get_c_interval 0 1 54 285
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_c_interval
//       Access: Published
//  Description: Returns the interval associated with the given index.
////////////////////////////////////////////////////////////////////
61
CInterval *CIntervalManager::get_c_interval(int index) const;

173 17 remove_c_interval 4 245 35 CIntervalManager::remove_c_interval 0 1 55 472
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::remove_c_interval
//       Access: Published
//  Description: Removes the indicated interval from the queue
//               immediately.  It will not be returned from
//               get_next_removal(), and none of its pending events,
//               if any, will be returned by get_next_event().
////////////////////////////////////////////////////////////////////
52
void CIntervalManager::remove_c_interval(int index);

174 9 interrupt 4 245 27 CIntervalManager::interrupt 0 1 56 605
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::interrupt
//       Access: Published
//  Description: Pauses or finishes (removes from the active queue)
//               all intervals tagged with auto_pause or auto_finish
//               set to true.  These are intervals that someone fired
//               up but won't necessarily expect to clean up; they can
//               be interrupted at will when necessary.
//
//               Returns the number of intervals affected.
////////////////////////////////////////////////////////////////////
38
int CIntervalManager::interrupt(void);

175 17 get_num_intervals 4 245 35 CIntervalManager::get_num_intervals 0 1 57 284
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_num_intervals
//       Access: Published
//  Description: Returns the number of currently active intervals.
////////////////////////////////////////////////////////////////////
52
int CIntervalManager::get_num_intervals(void) const;

176 13 get_max_index 4 245 31 CIntervalManager::get_max_index 0 1 58 591
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_max_index
//       Access: Published
//  Description: Returns one more than the largest interval index
//               number in the manager.  If you walk through all the
//               values between (0, get_max_index()] and call
//               get_c_interval() on each number, you will retrieve
//               all of the managed intervals (and possibly a number
//               of NULL pointers as well).
////////////////////////////////////////////////////////////////////
48
int CIntervalManager::get_max_index(void) const;

177 4 step 4 245 22 CIntervalManager::step 0 1 59 771
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::step
//       Access: Published
//  Description: This should be called every frame to do the
//               processing for all the active intervals.  It will
//               call step_play() for each interval that has been
//               added and that has not yet been removed.
//
//               After each call to step(), the scripting language
//               should call get_next_event() and get_next_removal()
//               repeatedly to process all the high-level
//               (e.g. Python-interval-based) events and to manage the
//               high-level list of intervals.
////////////////////////////////////////////////////////////////////
34
void CIntervalManager::step(void);

178 14 get_next_event 4 245 32 CIntervalManager::get_next_event 0 1 60 911
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_next_event
//       Access: Published
//  Description: This should be called by the scripting language after
//               each call to step().  It returns the index number of
//               the next interval that has events requiring servicing
//               by the scripting language, or -1 if no more intervals
//               have any events pending.
//
//               If this function returns something other than -1, it
//               is the scripting language's responsibility to query
//               the indicated interval for its next event via
//               get_event_index(), and eventually pop_event().
//
//               Then get_next_event() should be called again until it
//               returns -1.
////////////////////////////////////////////////////////////////////
43
int CIntervalManager::get_next_event(void);

179 16 get_next_removal 4 245 34 CIntervalManager::get_next_removal 0 1 61 694
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_next_removal
//       Access: Published
//  Description: This should be called by the scripting language after
//               each call to step().  It returns the index number of
//               an interval that was recently removed, or -1 if no
//               intervals were removed.
//
//               If this returns something other than -1, the
//               scripting language should clean up its own data
//               structures accordingly, and then call
//               get_next_removal() again.
////////////////////////////////////////////////////////////////////
45
int CIntervalManager::get_next_removal(void);

180 6 output 4 245 24 CIntervalManager::output 0 1 62 224
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
50
void CIntervalManager::output(ostream &out) const;

181 5 write 4 245 23 CIntervalManager::write 0 1 63 223
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
49
void CIntervalManager::write(ostream &out) const;

182 14 get_global_ptr 4 245 32 CIntervalManager::get_global_ptr 0 1 64 319
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_global_ptr
//       Access: Published, Static
//  Description: Returns the pointer to the one global
//               CIntervalManager object.
////////////////////////////////////////////////////////////////////
64
static CIntervalManager *CIntervalManager::get_global_ptr(void);

183 14 get_blend_type 4 246 29 CLerpInterval::get_blend_type 0 1 65 411
////////////////////////////////////////////////////////////////////
//     Function: CLerpInterval::get_blend_type
//       Access: Published
//  Description: Returns the blend type specified for the interval.
//               This controls how the linear interpolation behaves
//               near the beginning and end of the lerp period.
////////////////////////////////////////////////////////////////////
74
inline CLerpInterval::BlendType CLerpInterval::get_blend_type(void) const;

184 17 string_blend_type 4 246 32 CLerpInterval::string_blend_type 0 1 66 403
////////////////////////////////////////////////////////////////////
//     Function: CLerpInterval::string_blend_type
//       Access: Published, Static
//  Description: Returns the BlendType enumerated value corresponding
//               to the indicated string, or BT_invalid if the string
//               doesn't match anything.
////////////////////////////////////////////////////////////////////
105
static CLerpInterval::BlendType CLerpInterval::string_blend_type(basic_string< char > const &blend_type);

185 14 get_class_type 4 246 29 CLerpInterval::get_class_type 0 1 67 0
54
static TypeHandle CLerpInterval::get_class_type(void);

186 14 ~CLerpInterval 4 246 29 CLerpInterval::~CLerpInterval 0 0 0
36
CLerpInterval::~CLerpInterval(void);

187 23 CLerpAnimEffectInterval 4 248 48 CLerpAnimEffectInterval::CLerpAnimEffectInterval 0 1 68 923
// Filename: cLerpAnimEffectInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) 2001 - 2004, Disney Enterprises, Inc.  All rights reserved
//
// All use of this software is subject to the terms of the Panda 3d
// Software license.  You should have received a copy of this license
// along with this source code; you will also find a current copy of
// the license at http://etc.cmu.edu/panda3d/docs/license/ .
//
// To contact the maintainers of this program write to
// panda3d-general@lists.sourceforge.net .
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CLerpAnimEffectInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
144
inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(basic_string< char > const &name, double duration, CLerpInterval::BlendType blend_type);

188 11 add_control 4 248 36 CLerpAnimEffectInterval::add_control 0 1 69 573
////////////////////////////////////////////////////////////////////
//     Function: CLerpAnimEffectInterval::add_control
//       Access: Published
//  Description: Adds another AnimControl to the list of AnimControls
//               affected by the lerp.  This control will be lerped
//               from begin_effect to end_effect over the period of
//               the lerp.
//
//               The AnimControl name parameter is only used when
//               formatting the interval for output.
////////////////////////////////////////////////////////////////////
143
inline void CLerpAnimEffectInterval::add_control(AnimControl *control, basic_string< char > const &name, float begin_effect, float end_effect);

189 14 get_class_type 4 248 39 CLerpAnimEffectInterval::get_class_type 0 1 70 0
64
static TypeHandle CLerpAnimEffectInterval::get_class_type(void);

190 24 ~CLerpAnimEffectInterval 4 248 49 CLerpAnimEffectInterval::~CLerpAnimEffectInterval 0 0 0
56
CLerpAnimEffectInterval::~CLerpAnimEffectInterval(void);

191 21 CLerpNodePathInterval 4 249 44 CLerpNodePathInterval::CLerpNodePathInterval 0 1 71 1792
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::Constructor
//       Access: Published
//  Description: Constructs a lerp interval that will lerp some
//               properties on the indicated node, possibly relative
//               to the indicated other node (if other is nonempty).
//
//               You must call set_end_pos(), etc. for the various
//               properties you wish to lerp before the first call to
//               priv_initialize().  If you want to set a starting value
//               for any of the properties, you may call
//               set_start_pos(), etc.; otherwise, the starting value
//               is taken from the actual node's value at the time the
//               lerp is performed.
//
//               The starting values may be explicitly specified or
//               omitted.  The value of bake_in_start determines the
//               behavior if the starting values are omitted.  If
//               bake_in_start is true, the values are obtained the
//               first time the lerp runs, and thenceforth are stored
//               within the interval.  If bake_in_start is false, the
//               starting value is computed each frame, based on
//               assuming the current value represents the value set
//               from the last time the interval was run.  This
//               "smart" behavior allows code to manipulate the object
//               event while it is being lerped, and the lerp
//               continues to apply in a sensible way.
//
//               If fluid is true, the prev_transform is not adjusted
//               by the lerp; otherwise, it is reset.
////////////////////////////////////////////////////////////////////
210
CLerpNodePathInterval::CLerpNodePathInterval(basic_string< char > const &name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &node, NodePath const &other);

192 8 get_node 4 249 31 CLerpNodePathInterval::get_node 0 1 72 946
// Filename: cLerpNodePathInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) 2001 - 2004, Disney Enterprises, Inc.  All rights reserved
//
// All use of this software is subject to the terms of the Panda 3d
// Software license.  You should have received a copy of this license
// along with this source code; you will also find a current copy of
// the license at http://etc.cmu.edu/panda3d/docs/license/ .
//
// To contact the maintainers of this program write to
// panda3d-general@lists.sourceforge.net .
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_node
//       Access: Published
//  Description: Returns the node being lerped.
////////////////////////////////////////////////////////////////////
67
inline NodePath const &CLerpNodePathInterval::get_node(void) const;

193 9 get_other 4 249 32 CLerpNodePathInterval::get_other 0 1 73 451
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_other
//       Access: Published
//  Description: Returns the "other" node, which the lerped node is
//               being moved relative to.  If this is an empty node
//               path, the lerped node is being moved in its own
//               coordinate system.
////////////////////////////////////////////////////////////////////
68
inline NodePath const &CLerpNodePathInterval::get_other(void) const;

194 13 set_start_pos 4 249 36 CLerpNodePathInterval::set_start_pos 0 1 74 547
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_pos
//       Access: Published
//  Description: Indicates the initial position of the lerped node.
//               This is meaningful only if set_end_pos() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               position at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
72
inline void CLerpNodePathInterval::set_start_pos(LVecBase3f const &pos);

195 11 set_end_pos 4 249 34 CLerpNodePathInterval::set_end_pos 0 1 75 531
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_pos
//       Access: Published
//  Description: Indicates that the position of the node should be
//               lerped, and specifies the final position of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's position will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
70
inline void CLerpNodePathInterval::set_end_pos(LVecBase3f const &pos);

196 13 set_start_hpr 4 249 36 CLerpNodePathInterval::set_start_hpr 0 1 76 589
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_hpr
//       Access: Published
//  Description: Indicates the initial rotation of the lerped node.
//               This is meaningful only if either set_end_hpr() or
//               set_end_quat() is also called.  This parameter is
//               optional; if unspecified, the value will be taken
//               from the node's actual rotation at the time the lerp
//               is performed.
////////////////////////////////////////////////////////////////////
72
inline void CLerpNodePathInterval::set_start_hpr(LVecBase3f const &hpr);

197 11 set_end_hpr 4 249 34 CLerpNodePathInterval::set_end_hpr 0 2 77 78 1369
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_hpr
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_quat().  If
//               neither set_end_hpr() nor set_end_quat() is called,
//               the node's rotation will not be affected by the lerp.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_hpr
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This special function is overloaded to accept a
//               quaternion, even though the function name is
//               set_end_hpr().  The quaternion will be implicitly
//               converted to a HPR trio, and the lerp will be
//               performed in HPR space, componentwise.
////////////////////////////////////////////////////////////////////
70
inline void CLerpNodePathInterval::set_end_hpr(LVecBase3f const &hpr);

198 14 set_start_quat 4 249 37 CLerpNodePathInterval::set_start_quat 0 1 79 590
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_quat
//       Access: Published
//  Description: Indicates the initial rotation of the lerped node.
//               This is meaningful only if either set_end_quat() or
//               set_end_hpr() is also called.  This parameter is
//               optional; if unspecified, the value will be taken
//               from the node's actual rotation at the time the lerp
//               is performed.
////////////////////////////////////////////////////////////////////
76
inline void CLerpNodePathInterval::set_start_quat(LQuaternionf const &quat);

199 12 set_end_quat 4 249 35 CLerpNodePathInterval::set_end_quat 0 2 80 81 1589
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_quat
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_hpr().  If
//               neither set_end_quat() nor set_end_hpr() is called,
//               the node's rotation will not be affected by the lerp.
//
//               This special function is overloaded to accept a HPR
//               trio, even though the function name is
//               set_end_quat().  The HPR will be implicitly converted
//               to a quaternion, and the lerp will be performed in
//               quaternion space, as a spherical lerp.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_quat
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_hpr().  If
//               neither set_end_quat() nor set_end_hpr() is called,
//               the node's rotation will not be affected by the lerp.
////////////////////////////////////////////////////////////////////
71
inline void CLerpNodePathInterval::set_end_quat(LVecBase3f const &hpr);

200 15 set_start_scale 4 249 38 CLerpNodePathInterval::set_start_scale 0 2 82 83 1092
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_scale
//       Access: Published
//  Description: Indicates the initial scale of the lerped node.
//               This is meaningful only if set_end_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               scale at the time the lerp is performed.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_scale
//       Access: Published
//  Description: Indicates the initial scale of the lerped node.
//               This is meaningful only if set_end_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               scale at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
76
inline void CLerpNodePathInterval::set_start_scale(LVecBase3f const &scale);

201 13 set_end_scale 4 249 36 CLerpNodePathInterval::set_end_scale 0 2 84 85 1050
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_scale
//       Access: Published
//  Description: Indicates that the scale of the node should be
//               lerped, and specifies the final scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's scale will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_scale
//       Access: Published
//  Description: Indicates that the scale of the node should be
//               lerped, and specifies the final scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's scale will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
74
inline void CLerpNodePathInterval::set_end_scale(LVecBase3f const &scale);

202 15 set_start_shear 4 249 38 CLerpNodePathInterval::set_start_shear 0 1 86 545
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_shear
//       Access: Published
//  Description: Indicates the initial shear of the lerped node.
//               This is meaningful only if set_end_shear() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               shear at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
76
inline void CLerpNodePathInterval::set_start_shear(LVecBase3f const &shear);

203 13 set_end_shear 4 249 36 CLerpNodePathInterval::set_end_shear 0 1 87 524
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_shear
//       Access: Published
//  Description: Indicates that the shear of the node should be
//               lerped, and specifies the final shear of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's shear will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
74
inline void CLerpNodePathInterval::set_end_shear(LVecBase3f const &shear);

204 15 set_start_color 4 249 38 CLerpNodePathInterval::set_start_color 0 1 88 545
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_color
//       Access: Published
//  Description: Indicates the initial color of the lerped node.
//               This is meaningful only if set_end_color() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               color at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
76
inline void CLerpNodePathInterval::set_start_color(LVecBase4f const &color);

205 13 set_end_color 4 249 36 CLerpNodePathInterval::set_end_color 0 1 89 524
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_color
//       Access: Published
//  Description: Indicates that the color of the node should be
//               lerped, and specifies the final color of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's color will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
74
inline void CLerpNodePathInterval::set_end_color(LVecBase4f const &color);

206 21 set_start_color_scale 4 249 44 CLerpNodePathInterval::set_start_color_scale 0 1 90 569
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_color_scale
//       Access: Published
//  Description: Indicates the initial color scale of the lerped node.
//               This is meaningful only if set_end_color_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               color scale at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
88
inline void CLerpNodePathInterval::set_start_color_scale(LVecBase4f const &color_scale);

207 19 set_end_color_scale 4 249 42 CLerpNodePathInterval::set_end_color_scale 0 1 91 548
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_color_scale
//       Access: Published
//  Description: Indicates that the color scale of the node should be
//               lerped, and specifies the final color scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's color scale will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
86
inline void CLerpNodePathInterval::set_end_color_scale(LVecBase4f const &color_scale);

208 14 get_class_type 4 249 37 CLerpNodePathInterval::get_class_type 0 1 92 0
62
static TypeHandle CLerpNodePathInterval::get_class_type(void);

209 22 ~CLerpNodePathInterval 4 249 45 CLerpNodePathInterval::~CLerpNodePathInterval 0 0 0
52
CLerpNodePathInterval::~CLerpNodePathInterval(void);

210 13 CMetaInterval 4 250 28 CMetaInterval::CMetaInterval 0 1 93 226
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
63
CMetaInterval::CMetaInterval(basic_string< char > const &name);

211 13 set_precision 4 250 28 CMetaInterval::set_precision 0 1 94 1389
// Filename: cMetaInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) 2001 - 2004, Disney Enterprises, Inc.  All rights reserved
//
// All use of this software is subject to the terms of the Panda 3d
// Software license.  You should have received a copy of this license
// along with this source code; you will also find a current copy of
// the license at http://etc.cmu.edu/panda3d/docs/license/ .
//
// To contact the maintainers of this program write to
// panda3d-general@lists.sourceforge.net .
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_precision
//       Access: Published
//  Description: Indicates the precision with which time measurements
//               are compared.  For numerical accuracy, all
//               floating-point time values are converted to integer
//               values internally by scaling by the precision factor.
//               The larger the number given here, the smaller the
//               delta of time that can be differentiated; the
//               limit is the maximum integer that can be represented
//               in the system.
////////////////////////////////////////////////////////////////////
59
inline void CMetaInterval::set_precision(double precision);

212 13 get_precision 4 250 28 CMetaInterval::get_precision 0 1 95 331
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_precision
//       Access: Published
//  Description: Returns the precision with which time measurements
//               are compared.  See set_precision().
////////////////////////////////////////////////////////////////////
55
inline double CMetaInterval::get_precision(void) const;

213 15 clear_intervals 4 250 30 CMetaInterval::clear_intervals 0 1 96 314
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::clear_intervals
//       Access: Published
//  Description: Resets the list of intervals and prepares for
//               receiving a new list.
////////////////////////////////////////////////////////////////////
42
void CMetaInterval::clear_intervals(void);

214 10 push_level 4 250 25 CMetaInterval::push_level 0 1 97 647
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::push_level
//       Access: Published
//  Description: Marks the beginning of a nested level of child
//               intervals.  Within the nested level, a RelativeStart
//               time of RS_level_begin refers to the start of the
//               level, and the first interval added within the level
//               is always relative to the start of the level.
//
//               The return value is the index of the def entry
//               created by this push.
////////////////////////////////////////////////////////////////////
118
int CMetaInterval::push_level(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to);

215 14 add_c_interval 4 250 29 CMetaInterval::add_c_interval 0 1 98 512
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_c_interval
//       Access: Published
//  Description: Adds a new CInterval to the list.  The interval will
//               be played when the indicated time (relative to the
//               given point) has been reached.
//
//               The return value is the index of the def entry
//               representing the new interval.
////////////////////////////////////////////////////////////////////
111
int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time, CMetaInterval::RelativeStart rel_to);

216 13 add_ext_index 4 250 28 CMetaInterval::add_ext_index 0 1 99 1156
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_ext_index
//       Access: Published
//  Description: Adds a new external interval to the list.  This
//               represents some object in the external scripting
//               language that has properties similar to a CInterval
//               (for instance, a Python Interval object).
//
//               The CMetaInterval object cannot play this external
//               interval directly, but it records a placeholder for
//               it and will ask the scripting language to play it
//               when it is time, via is_event_ready() and related
//               methods.
//
//               The ext_index number itself is simply a handle that
//               the scripting language makes up and associates with
//               its interval object somehow.  The CMetaInterval
//               object does not attempt to interpret this value.
//
//               The return value is the index of the def entry
//               representing the new interval.
////////////////////////////////////////////////////////////////////
170
int CMetaInterval::add_ext_index(int ext_index, basic_string< char > const &name, double duration, bool open_ended, double rel_time, CMetaInterval::RelativeStart rel_to);

217 9 pop_level 4 250 24 CMetaInterval::pop_level 0 2 100 101 645
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_level
//       Access: Published
//  Description: Finishes a level marked by a previous call to
//               push_level(), and returns to the previous level.
//
//               If the duration is not negative, it represents a
//               phony duration to assign to the level, for the
//               purposes of sequencing later intervals.  Otherwise,
//               the level's duration is computed based on the
//               intervals within the level.
////////////////////////////////////////////////////////////////////
53
int CMetaInterval::pop_level(double duration = (-1));

218 23 set_interval_start_time 4 250 38 CMetaInterval::set_interval_start_time 0 2 102 103 824
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_interval_start_time
//       Access: Published
//  Description: Adjusts the start time of the child interval with the
//               given name, if found.  This may be either a C++
//               interval added via add_c_interval(), or an external
//               interval added via add_ext_index(); the name must
//               match exactly.
//
//               If the interval is found, its start time is adjusted,
//               and all subsequent intervals are adjusting
//               accordingly, and true is returned.  If a matching
//               interval is not found, nothing is changed and false
//               is returned.
////////////////////////////////////////////////////////////////////
151
bool CMetaInterval::set_interval_start_time(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to = (RS_level_begin));

219 23 get_interval_start_time 4 250 38 CMetaInterval::get_interval_start_time 0 1 104 451
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_interval_start_time
//       Access: Published
//  Description: Returns the actual start time, relative to the
//               beginning of the interval, of the child interval with
//               the given name, if found, or -1 if the interval is
//               not found.
////////////////////////////////////////////////////////////////////
86
double CMetaInterval::get_interval_start_time(basic_string< char > const &name) const;

220 21 get_interval_end_time 4 250 36 CMetaInterval::get_interval_end_time 0 1 105 447
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_interval_end_time
//       Access: Published
//  Description: Returns the actual end time, relative to the
//               beginning of the interval, of the child interval with
//               the given name, if found, or -1 if the interval is
//               not found.
////////////////////////////////////////////////////////////////////
84
double CMetaInterval::get_interval_end_time(basic_string< char > const &name) const;

221 12 get_num_defs 4 250 27 CMetaInterval::get_num_defs 0 1 106 359
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_num_defs
//       Access: Published
//  Description: Returns the number of interval and push/pop
//               definitions that have been added to the meta
//               interval.
////////////////////////////////////////////////////////////////////
51
inline int CMetaInterval::get_num_defs(void) const;

222 12 get_def_type 4 250 27 CMetaInterval::get_def_type 0 1 107 312
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_def_type
//       Access: Published
//  Description: Returns the type of the nth interval definition that
//               has been added.
////////////////////////////////////////////////////////////////////
71
inline CMetaInterval::DefType CMetaInterval::get_def_type(int n) const;

223 14 get_c_interval 4 250 29 CMetaInterval::get_c_interval 0 1 108 409
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_c_interval
//       Access: Published
//  Description: Return the CInterval pointer associated with the nth
//               interval definition.  It is only valid to call this
//               if get_def_type(n) returns DT_c_interval.
////////////////////////////////////////////////////////////////////
61
inline CInterval *CMetaInterval::get_c_interval(int n) const;

224 13 get_ext_index 4 250 28 CMetaInterval::get_ext_index 0 1 109 420
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_ext_index
//       Access: Published
//  Description: Return the external interval index number associated
//               with the nth interval definition.  It is only valid
//               to call this if get_def_type(n) returns DT_ext_index.
////////////////////////////////////////////////////////////////////
53
inline int CMetaInterval::get_ext_index(int n) const;

225 14 is_event_ready 4 250 29 CMetaInterval::is_event_ready 0 1 110 544
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::is_event_ready
//       Access: Published
//  Description: Returns true if a recent call to priv_initialize(),
//               priv_step(), or priv_finalize() has left some external
//               intervals ready to play.  If this returns true, call
//               get_event_index(), get_event_t(), and pop_event() to
//               retrieve the relevant information.
////////////////////////////////////////////////////////////////////
48
inline bool CMetaInterval::is_event_ready(void);

226 15 get_event_index 4 250 30 CMetaInterval::get_event_index 0 1 111 444
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_index
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the index number (added via
//               add_event_index()) of the external interval that needs
//               to be played.
////////////////////////////////////////////////////////////////////
54
inline int CMetaInterval::get_event_index(void) const;

227 11 get_event_t 4 250 26 CMetaInterval::get_event_t 0 1 112 380
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_t
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the t value that should be fed to
//               the given interval.
////////////////////////////////////////////////////////////////////
53
inline double CMetaInterval::get_event_t(void) const;

228 14 get_event_type 4 250 29 CMetaInterval::get_event_type 0 1 113 410
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_type
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the type of the event (initialize,
//               step, finalize, etc.) for the given interval.
////////////////////////////////////////////////////////////////////
70
inline CInterval::EventType CMetaInterval::get_event_type(void) const;

229 9 pop_event 4 250 24 CMetaInterval::pop_event 0 1 114 591
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_event
//       Access: Published
//  Description: Acknowledges that the external interval on the top of
//               the queue has been extracted, and is about to be
//               serviced by the scripting language.  This prepares
//               the interval so the next call to is_event_ready()
//               will return information about the next external
//               interval on the queue, if any.
////////////////////////////////////////////////////////////////////
36
void CMetaInterval::pop_event(void);

230 8 timeline 4 250 23 CMetaInterval::timeline 0 1 115 302
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::timeline
//       Access: Published
//  Description: Outputs a list of all events in the order in which
//               they occur.
////////////////////////////////////////////////////////////////////
49
void CMetaInterval::timeline(ostream &out) const;

231 14 get_class_type 4 250 29 CMetaInterval::get_class_type 0 1 116 0
54
static TypeHandle CMetaInterval::get_class_type(void);

232 12 HideInterval 4 253 26 HideInterval::HideInterval 0 2 117 118 225
////////////////////////////////////////////////////////////////////
//     Function: HideInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
98
HideInterval::HideInterval(NodePath const &node, basic_string< char > const &name = ((string())));

233 14 get_class_type 4 253 28 HideInterval::get_class_type 0 1 119 0
53
static TypeHandle HideInterval::get_class_type(void);

234 13 ~HideInterval 4 253 27 HideInterval::~HideInterval 0 0 0
34
HideInterval::~HideInterval(void);

235 12 ShowInterval 4 254 26 ShowInterval::ShowInterval 0 2 120 121 225
////////////////////////////////////////////////////////////////////
//     Function: ShowInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
98
ShowInterval::ShowInterval(NodePath const &node, basic_string< char > const &name = ((string())));

236 14 get_class_type 4 254 28 ShowInterval::get_class_type 0 1 122 0
53
static TypeHandle ShowInterval::get_class_type(void);

237 13 ~ShowInterval 4 254 27 ShowInterval::~ShowInterval 0 0 0
34
ShowInterval::~ShowInterval(void);

238 12 WaitInterval 4 255 26 WaitInterval::WaitInterval 0 1 123 1015
// Filename: waitInterval.I
// Created by:  drose (12Sep02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) 2001 - 2004, Disney Enterprises, Inc.  All rights reserved
//
// All use of this software is subject to the terms of the Panda 3d
// Software license.  You should have received a copy of this license
// along with this source code; you will also find a current copy of
// the license at http://etc.cmu.edu/panda3d/docs/license/ .
//
// To contact the maintainers of this program write to
// panda3d-general@lists.sourceforge.net .
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: WaitInterval::Constructor
//       Access: Published
//  Description: All Wait intervals have the same name.  No one really
//               cares if their names are unique, after all.
////////////////////////////////////////////////////////////////////
51
inline WaitInterval::WaitInterval(double duration);

239 14 get_class_type 4 255 28 WaitInterval::get_class_type 0 1 124 0
53
static TypeHandle WaitInterval::get_class_type(void);

240 13 ~WaitInterval 4 255 27 WaitInterval::~WaitInterval 0 0 0
34
WaitInterval::~WaitInterval(void);

124
1 14 Dtool_SpsCfV5F 6 3 258 0 14 Dtool_SpsCfV5F 1 4 this 3 256  
2 14 Dtool_SpsC8svE 6 4 259 0 14 Dtool_SpsC8svE 1 4 this 3 256  
3 14 Dtool_SpsCB6uv 6 5 260 0 14 Dtool_SpsCB6uv 1 4 this 3 256  
4 14 Dtool_SpsCvfjT 6 8 244 0 14 Dtool_SpsCvfjT 1 4 this 3 256  
5 14 Dtool_SpsCs6CA 6 9 260 0 14 Dtool_SpsCs6CA 1 4 this 3 256  
6 14 Dtool_SpsCso5p 4 10 262 0 14 Dtool_SpsCso5p 2 4 this 3 261  5 event 1 258  
7 14 Dtool_SpsCU1_s 6 11 258 0 14 Dtool_SpsCU1_s 1 4 this 3 256  
8 14 Dtool_SpsCnHap 4 12 262 0 14 Dtool_SpsCnHap 2 4 this 3 261  1 t 1 259  
9 14 Dtool_SpsCEMrp 6 13 259 0 14 Dtool_SpsCEMrp 1 4 this 3 256  
10 14 Dtool_SpsCK6Bt 4 14 262 0 14 Dtool_SpsCK6Bt 2 4 this 3 261  10 auto_pause 1 260  
11 14 Dtool_SpsCLOK8 6 15 260 0 14 Dtool_SpsCLOK8 1 4 this 3 256  
12 14 Dtool_SpsCwEgz 4 16 262 0 14 Dtool_SpsCwEgz 2 4 this 3 261  11 auto_finish 1 260  
13 14 Dtool_SpsCK3xj 6 17 260 0 14 Dtool_SpsCK3xj 1 4 this 3 256  
14 14 Dtool_SpsCU4Wd 4 18 262 0 14 Dtool_SpsCU4Wd 2 4 this 3 261  16 wants_t_callback 1 260  
15 14 Dtool_SpsCzuIb 6 19 260 0 14 Dtool_SpsCzuIb 1 4 this 3 256  
16 14 Dtool_SpsCVrzY 4 20 262 0 14 Dtool_SpsCVrzY 2 4 this 3 261  7 manager 1 263  
17 14 Dtool_SpsCzijv 6 21 263 0 14 Dtool_SpsCzijv 1 4 this 3 256  
18 14 Dtool_SpsCOA1D 4 22 262 0 14 Dtool_SpsCOA1D 4 4 this 3 261  7 start_t 1 259  5 end_t 1 259  9 play_rate 1 259  
19 14 Dtool_SpsCsz84 4 22 262 0 14 Dtool_SpsCsz84 3 4 this 3 261  7 start_t 1 259  5 end_t 1 259  
20 14 Dtool_SpsCV_pK 4 22 262 0 14 Dtool_SpsCV_pK 2 4 this 3 261  7 start_t 1 259  
21 14 Dtool_SpsCI9Ch 4 22 262 0 14 Dtool_SpsCI9Ch 1 4 this 3 261  
22 14 Dtool_SpsClvuV 4 23 262 0 14 Dtool_SpsClvuV 4 4 this 3 261  7 start_t 1 259  5 end_t 1 259  9 play_rate 1 259  
23 14 Dtool_SpsCN0b7 4 23 262 0 14 Dtool_SpsCN0b7 3 4 this 3 261  7 start_t 1 259  5 end_t 1 259  
24 14 Dtool_SpsCDdAk 4 23 262 0 14 Dtool_SpsCDdAk 2 4 this 3 261  7 start_t 1 259  
25 14 Dtool_SpsCdHuO 4 23 262 0 14 Dtool_SpsCdHuO 1 4 this 3 261  
26 14 Dtool_SpsCYZXB 6 24 259 0 14 Dtool_SpsCYZXB 1 4 this 3 261  
27 14 Dtool_SpsCOoeF 4 25 262 0 14 Dtool_SpsCOoeF 1 4 this 3 261  
28 14 Dtool_SpsCC2L6 4 25 262 0 14 Dtool_SpsCC2L6 2 4 this 3 261  7 start_t 1 259  
29 14 Dtool_SpsCYMh8 4 26 262 0 14 Dtool_SpsCYMh8 2 4 this 3 261  5 end_t 1 259  
30 14 Dtool_SpsCIWoe 4 27 262 0 14 Dtool_SpsCIWoe 1 4 this 3 261  
31 14 Dtool_SpsC9awK 4 28 262 0 14 Dtool_SpsC9awK 1 4 this 3 261  
32 14 Dtool_SpsCLlcY 6 29 260 0 14 Dtool_SpsCLlcY 1 4 this 3 256  
33 14 Dtool_SpsCsrd8 4 30 262 0 14 Dtool_SpsCsrd8 3 4 this 3 261  1 t 1 259  5 event 1 243  
34 14 Dtool_SpsCADw2 4 31 262 0 14 Dtool_SpsCADw2 2 4 this 3 261  1 t 1 259  
35 14 Dtool_SpsC_B_n 4 32 262 0 14 Dtool_SpsC_B_n 1 4 this 3 261  
36 14 Dtool_SpsCU3CU 4 33 262 0 14 Dtool_SpsCU3CU 2 4 this 3 261  1 t 1 259  
37 14 Dtool_SpsCcdRd 4 34 262 0 14 Dtool_SpsCcdRd 1 4 this 3 261  
38 14 Dtool_SpsCzQVo 4 35 262 0 14 Dtool_SpsCzQVo 2 4 this 3 261  1 t 1 259  
39 14 Dtool_SpsCyAlT 4 36 262 0 14 Dtool_SpsCyAlT 1 4 this 3 261  
40 14 Dtool_SpsCtoBu 4 37 262 0 14 Dtool_SpsCtoBu 1 4 this 3 261  
41 14 Dtool_SpsCpKBe 4 38 262 0 14 Dtool_SpsCpKBe 1 4 this 3 261  
42 14 Dtool_SpsC6w_D 4 39 262 0 14 Dtool_SpsC6w_D 2 4 this 3 256  3 out 1 264  
43 14 Dtool_SpsCLeD7 4 40 262 0 14 Dtool_SpsCLeD7 3 4 this 3 256  3 out 1 264  12 indent_level 1 266  
44 14 Dtool_SpsCzgQa 4 41 262 0 14 Dtool_SpsCzgQa 5 4 this 3 261  10 start_time 1 259  8 end_time 1 259  9 play_rate 1 259  7 do_loop 1 260  
45 14 Dtool_SpsCUryc 4 42 262 0 14 Dtool_SpsCUryc 1 4 this 3 261  
46 14 Dtool_SpsCscch 4 43 262 0 14 Dtool_SpsCscch 2 4 this 3 261  5 end_t 1 259  
47 14 Dtool_SpsCNGqy 6 44 260 0 14 Dtool_SpsCNGqy 1 4 this 3 261  
48 14 Dtool_SpsCStxv 7 45 268 0 14 Dtool_SpsCStxv 0 
49 14 Dtool_SpsC7SV3 7 47 263 167 14 Dtool_SpsC7SV3 0 
50 14 Dtool_SpsCH947 4 49 262 0 14 Dtool_SpsCH947 2 4 this 3 263  11 event_queue 1 269  
51 14 Dtool_SpsC4ah3 6 50 269 0 14 Dtool_SpsC4ah3 1 4 this 3 271  
52 14 Dtool_SpsCyh7A 6 51 266 0 14 Dtool_SpsCyh7A 3 4 this 3 263  8 interval 1 261  8 external 1 260  
53 14 Dtool_SpsCA0H3 6 52 266 0 14 Dtool_SpsCA0H3 2 4 this 3 271  4 name 1 258  
54 14 Dtool_SpsCnvsF 7 53 261 0 14 Dtool_SpsCnvsF 2 4 this 3 271  5 index 1 266  
55 14 Dtool_SpsCPxys 4 54 262 0 14 Dtool_SpsCPxys 2 4 this 3 263  5 index 1 266  
56 14 Dtool_SpsCwZTK 6 55 266 0 14 Dtool_SpsCwZTK 1 4 this 3 263  
57 14 Dtool_SpsCW9zD 6 56 266 0 14 Dtool_SpsCW9zD 1 4 this 3 271  
58 14 Dtool_SpsCrnjb 6 57 266 0 14 Dtool_SpsCrnjb 1 4 this 3 271  
59 14 Dtool_SpsCjQ_p 4 58 262 0 14 Dtool_SpsCjQ_p 1 4 this 3 263  
60 14 Dtool_SpsCgEV_ 6 59 266 0 14 Dtool_SpsCgEV_ 1 4 this 3 263  
61 14 Dtool_SpsCyDVA 6 60 266 0 14 Dtool_SpsCyDVA 1 4 this 3 263  
62 14 Dtool_SpsCJ5QE 4 61 262 0 14 Dtool_SpsCJ5QE 2 4 this 3 271  3 out 1 264  
63 14 Dtool_SpsCzWze 4 62 262 0 14 Dtool_SpsCzWze 2 4 this 3 271  3 out 1 264  
64 14 Dtool_SpsCTP38 6 63 263 0 14 Dtool_SpsCTP38 0 
65 14 Dtool_SpsCg1iu 6 66 247 0 14 Dtool_SpsCg1iu 1 4 this 3 273  
66 14 Dtool_SpsCHWfc 6 67 247 0 14 Dtool_SpsCHWfc 1 10 blend_type 1 258  
67 14 Dtool_SpsCFioW 7 68 268 0 14 Dtool_SpsCFioW 0 
68 14 Dtool_SpsCZ1mi 7 71 275 190 14 Dtool_SpsCZ1mi 3 4 name 1 258  8 duration 1 259  10 blend_type 1 247  
69 14 Dtool_SpsCPyvp 4 72 262 0 14 Dtool_SpsCPyvp 5 4 this 3 275  7 control 1 276  4 name 1 258  12 begin_effect 1 278  10 end_effect 1 278  
70 14 Dtool_SpsCxulU 7 73 268 0 14 Dtool_SpsCxulU 0 
71 14 Dtool_SpsCdIA4 7 76 282 209 14 Dtool_SpsCdIA4 7 4 name 1 258  8 duration 1 259  10 blend_type 1 247  13 bake_in_start 1 260  5 fluid 1 260  4 node 1 279  5 other 1 279  
72 14 Dtool_SpsC9PvW 6 77 279 0 14 Dtool_SpsC9PvW 1 4 this 3 283  
73 14 Dtool_SpsCSM_v 6 78 279 0 14 Dtool_SpsCSM_v 1 4 this 3 283  
74 14 Dtool_SpsCaRxY 4 79 262 0 14 Dtool_SpsCaRxY 2 4 this 3 282  3 pos 1 285  
75 14 Dtool_SpsCJiNY 4 80 262 0 14 Dtool_SpsCJiNY 2 4 this 3 282  3 pos 1 285  
76 14 Dtool_SpsClyYW 4 81 262 0 14 Dtool_SpsClyYW 2 4 this 3 282  3 hpr 1 285  
77 14 Dtool_SpsCRVh4 4 82 262 0 14 Dtool_SpsCRVh4 2 4 this 3 282  4 quat 1 288  
78 14 Dtool_SpsCrohJ 4 82 262 0 14 Dtool_SpsCrohJ 2 4 this 3 282  3 hpr 1 285  
79 14 Dtool_SpsCc5Xe 4 83 262 0 14 Dtool_SpsCc5Xe 2 4 this 3 282  4 quat 1 288  
80 14 Dtool_SpsCt__n 4 84 262 0 14 Dtool_SpsCt__n 2 4 this 3 282  4 quat 1 288  
81 14 Dtool_SpsCGCRI 4 84 262 0 14 Dtool_SpsCGCRI 2 4 this 3 282  3 hpr 1 285  
82 14 Dtool_SpsCPMwu 4 85 262 0 14 Dtool_SpsCPMwu 2 4 this 3 282  5 scale 1 285  
83 14 Dtool_SpsCLfsN 4 85 262 0 14 Dtool_SpsCLfsN 2 4 this 3 282  5 scale 1 278  
84 14 Dtool_SpsCu_6i 4 86 262 0 14 Dtool_SpsCu_6i 2 4 this 3 282  5 scale 1 285  
85 14 Dtool_SpsCBCOk 4 86 262 0 14 Dtool_SpsCBCOk 2 4 this 3 282  5 scale 1 278  
86 14 Dtool_SpsCyKML 4 87 262 0 14 Dtool_SpsCyKML 2 4 this 3 282  5 shear 1 285  
87 14 Dtool_SpsC1jlK 4 88 262 0 14 Dtool_SpsC1jlK 2 4 this 3 282  5 shear 1 285  
88 14 Dtool_SpsCt8Tw 4 89 262 0 14 Dtool_SpsCt8Tw 2 4 this 3 282  5 color 1 291  
89 14 Dtool_SpsCUGzY 4 90 262 0 14 Dtool_SpsCUGzY 2 4 this 3 282  5 color 1 291  
90 14 Dtool_SpsCJuh7 4 91 262 0 14 Dtool_SpsCJuh7 2 4 this 3 282  11 color_scale 1 291  
91 14 Dtool_SpsCUY_S 4 92 262 0 14 Dtool_SpsCUY_S 2 4 this 3 282  11 color_scale 1 291  
92 14 Dtool_SpsCdTLY 7 93 268 0 14 Dtool_SpsCdTLY 0 
93 14 Dtool_SpsCfll2 7 96 294 0 14 Dtool_SpsCfll2 1 4 name 1 258  
94 14 Dtool_SpsCxSCe 4 98 262 0 14 Dtool_SpsCxSCe 2 4 this 3 294  9 precision 1 259  
95 14 Dtool_SpsC5PcZ 6 99 259 0 14 Dtool_SpsC5PcZ 1 4 this 3 295  
96 14 Dtool_SpsCS3bp 4 100 262 0 14 Dtool_SpsCS3bp 1 4 this 3 294  
97 14 Dtool_SpsCe1kF 6 101 266 0 14 Dtool_SpsCe1kF 4 4 this 3 294  4 name 1 258  8 rel_time 1 259  6 rel_to 1 251  
98 14 Dtool_SpsC8fyX 6 102 266 0 14 Dtool_SpsC8fyX 4 4 this 3 294  10 c_interval 1 261  8 rel_time 1 259  6 rel_to 1 251  
99 14 Dtool_SpsCsI0L 6 103 266 0 14 Dtool_SpsCsI0L 7 4 this 3 294  9 ext_index 1 266  4 name 1 258  8 duration 1 259  10 open_ended 1 260  8 rel_time 1 259  6 rel_to 1 251  
100 14 Dtool_SpsCAQho 6 104 266 0 14 Dtool_SpsCAQho 2 4 this 3 294  8 duration 1 259  
101 14 Dtool_SpsCcB29 6 104 266 0 14 Dtool_SpsCcB29 1 4 this 3 294  
102 14 Dtool_SpsCbNvh 6 105 260 0 14 Dtool_SpsCbNvh 4 4 this 3 294  4 name 1 258  8 rel_time 1 259  6 rel_to 1 251  
103 14 Dtool_SpsCDRqF 6 105 260 0 14 Dtool_SpsCDRqF 3 4 this 3 294  4 name 1 258  8 rel_time 1 259  
104 14 Dtool_SpsCnjRJ 6 106 259 0 14 Dtool_SpsCnjRJ 2 4 this 3 295  4 name 1 258  
105 14 Dtool_SpsCwxHv 6 107 259 0 14 Dtool_SpsCwxHv 2 4 this 3 295  4 name 1 258  
106 14 Dtool_SpsC4MwM 6 109 266 0 14 Dtool_SpsC4MwM 1 4 this 3 295  
107 14 Dtool_SpsCleqy 6 110 252 0 14 Dtool_SpsCleqy 2 4 this 3 295  1 n 1 266  
108 14 Dtool_SpsClcyM 7 111 261 0 14 Dtool_SpsClcyM 2 4 this 3 295  1 n 1 266  
109 14 Dtool_SpsCDZwS 6 112 266 0 14 Dtool_SpsCDZwS 2 4 this 3 295  1 n 1 266  
110 14 Dtool_SpsCG_g4 6 113 260 0 14 Dtool_SpsCG_g4 1 4 this 3 294  
111 14 Dtool_SpsCdJvv 6 114 266 0 14 Dtool_SpsCdJvv 1 4 this 3 295  
112 14 Dtool_SpsCPQNU 6 115 259 0 14 Dtool_SpsCPQNU 1 4 this 3 295  
113 14 Dtool_SpsCsP8v 6 116 243 0 14 Dtool_SpsCsP8v 1 4 this 3 295  
114 14 Dtool_SpsC4v7o 4 117 262 0 14 Dtool_SpsC4v7o 1 4 this 3 294  
115 14 Dtool_SpsCXzrj 4 118 262 0 14 Dtool_SpsCXzrj 2 4 this 3 295  3 out 1 264  
116 14 Dtool_SpsCQy_U 7 119 268 0 14 Dtool_SpsCQy_U 0 
117 14 Dtool_SpsCVO63 7 121 297 234 14 Dtool_SpsCVO63 2 4 node 1 279  4 name 1 258  
118 14 Dtool_SpsC866V 7 121 297 234 14 Dtool_SpsC866V 1 4 node 1 279  
119 14 Dtool_SpsCVV6X 7 122 268 0 14 Dtool_SpsCVV6X 0 
120 14 Dtool_SpsCNLk_ 7 125 298 237 14 Dtool_SpsCNLk_ 2 4 node 1 279  4 name 1 258  
121 14 Dtool_SpsCxxld 7 125 298 237 14 Dtool_SpsCxxld 1 4 node 1 279  
122 14 Dtool_SpsC1PEe 7 126 268 0 14 Dtool_SpsC1PEe 0 
123 14 Dtool_SpsCJUNH 7 129 299 240 14 Dtool_SpsCJUNH 1 8 duration 1 259  
124 14 Dtool_SpsCowFS 7 130 268 0 14 Dtool_SpsCowFS 0 
59
241 9 CInterval 75777 9 CInterval 9 CInterval 0 0 0 0 0 0 41 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 0 1 0 242 0 0 0 2 243 244 780
////////////////////////////////////////////////////////////////////
//       Class : CInterval
// Description : The base class for timeline components.  A CInterval
//               represents a single action, event, or collection of
//               nested intervals that will be performed at some
//               specific time or over a period of time.
//
//               This is essentially similar to the Python "Interval"
//               class, but it is implemented in C++ (hence the name).
//               Intervals that may be implemented in C++ will inherit
//               from this class; Intervals that must be implemented
//               in Python will inherit from the similar Python class.
////////////////////////////////////////////////////////////////////

242 19 TypedReferenceCount 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 710
////////////////////////////////////////////////////////////////////
//       Class : TypedReferenceCount
// Description : A base class for things which need to inherit from
//               both TypedObject and from ReferenceCount.  It's
//               convenient to define this intermediate base class
//               instead of multiply inheriting from the two classes
//               each time they are needed, so that we can sensibly
//               pass around pointers to things which are both
//               TypedObjects and ReferenceCounters.
//               
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

243 9 EventType 794624 20 CInterval::EventType 20 CInterval::EventType 241 0 0 0 0 0 0 0 0 8 13 ET_initialize 24 CInterval::ET_initialize 0 10 ET_instant 21 CInterval::ET_instant 1 7 ET_step 18 CInterval::ET_step 2 11 ET_finalize 22 CInterval::ET_finalize 3 21 ET_reverse_initialize 32 CInterval::ET_reverse_initialize 4 18 ET_reverse_instant 29 CInterval::ET_reverse_instant 5 19 ET_reverse_finalize 30 CInterval::ET_reverse_finalize 6 12 ET_interrupt 23 CInterval::ET_interrupt 7 0 0

244 5 State 794624 16 CInterval::State 16 CInterval::State 241 0 0 0 0 0 0 0 0 4 9 S_initial 20 CInterval::S_initial 0 9 S_started 20 CInterval::S_started 1 8 S_paused 19 CInterval::S_paused 2 7 S_final 18 CInterval::S_final 3 0 0

245 16 CIntervalManager 26625 16 CIntervalManager 16 CIntervalManager 0 0 0 1 166 167 0 15 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 0 0 0 0 777
////////////////////////////////////////////////////////////////////
//       Class : CIntervalManager
// Description : This object holds a number of currently-playing
//               intervals and is responsible for advancing them each
//               frame as needed.
//
//               There is normally only one IntervalManager object in
//               the world, and it is the responsibility of the
//               scripting language to call step() on this object once
//               each frame, and to then process the events indicated by
//               get_next_event().  
//
//               It is also possible to create multiple
//               IntervalManager objects for special needs.
////////////////////////////////////////////////////////////////////

246 13 CLerpInterval 141313 13 CLerpInterval 13 CLerpInterval 0 0 0 0 186 0 3 183 184 185 0 1 0 241 0 0 0 1 247 324
////////////////////////////////////////////////////////////////////
//       Class : CLerpInterval
// Description : The base class for a family of intervals that
//               linearly interpolate one or more numeric values over
//               time.
////////////////////////////////////////////////////////////////////

247 9 BlendType 794624 24 CLerpInterval::BlendType 24 CLerpInterval::BlendType 246 0 0 0 0 0 0 0 0 5 11 BT_no_blend 26 CLerpInterval::BT_no_blend 0 10 BT_ease_in 25 CLerpInterval::BT_ease_in 1 11 BT_ease_out 26 CLerpInterval::BT_ease_out 2 14 BT_ease_in_out 29 CLerpInterval::BT_ease_in_out 3 10 BT_invalid 25 CLerpInterval::BT_invalid 4 0 0

248 23 CLerpAnimEffectInterval 141313 23 CLerpAnimEffectInterval 23 CLerpAnimEffectInterval 0 0 0 1 187 190 0 2 188 189 0 1 0 246 0 0 0 0 649
////////////////////////////////////////////////////////////////////
//       Class : CLerpAnimEffectInterval
// Description : This interval lerps between different amounts of
//               control effects for various AnimControls that might
//               be playing on an actor.  It's used to change the
//               blending amount between multiple animations.
//
//               The idea is to start all the animations playing
//               first, then use a CLerpAnimEffectInterval to adjust
//               the degree to which each animation affects the actor.
////////////////////////////////////////////////////////////////////

249 21 CLerpNodePathInterval 141313 21 CLerpNodePathInterval 21 CLerpNodePathInterval 0 0 0 1 191 209 0 17 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 0 1 0 246 0 0 0 0 303
////////////////////////////////////////////////////////////////////
//       Class : CLerpNodePathInterval
// Description : An interval that lerps one or more properties (like
//               pos, hpr, etc.) on a NodePath over time.
////////////////////////////////////////////////////////////////////

250 13 CMetaInterval 75777 13 CMetaInterval 13 CMetaInterval 0 0 0 1 210 0 0 21 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 0 1 0 241 0 0 0 2 251 252 369
////////////////////////////////////////////////////////////////////
//       Class : CMetaInterval
// Description : This interval contains a list of nested intervals,
//               each of which has its own begin and end times.  Some
//               of them may overlap and some of them may not.
////////////////////////////////////////////////////////////////////

251 13 RelativeStart 794624 28 CMetaInterval::RelativeStart 28 CMetaInterval::RelativeStart 250 0 0 0 0 0 0 0 0 3 15 RS_previous_end 30 CMetaInterval::RS_previous_end 0 17 RS_previous_begin 32 CMetaInterval::RS_previous_begin 1 14 RS_level_begin 29 CMetaInterval::RS_level_begin 2 0 0

252 7 DefType 794624 22 CMetaInterval::DefType 22 CMetaInterval::DefType 250 0 0 0 0 0 0 0 0 4 13 DT_c_interval 28 CMetaInterval::DT_c_interval 0 12 DT_ext_index 27 CMetaInterval::DT_ext_index 1 13 DT_push_level 28 CMetaInterval::DT_push_level 2 12 DT_pop_level 27 CMetaInterval::DT_pop_level 3 0 0

253 12 HideInterval 141313 12 HideInterval 12 HideInterval 0 0 0 1 232 234 0 1 233 0 1 0 241 0 0 0 0 225
////////////////////////////////////////////////////////////////////
//       Class : HideInterval
// Description : An interval that calls NodePath::hide().
////////////////////////////////////////////////////////////////////

254 12 ShowInterval 141313 12 ShowInterval 12 ShowInterval 0 0 0 1 235 237 0 1 236 0 1 0 241 0 0 0 0 225
////////////////////////////////////////////////////////////////////
//       Class : ShowInterval
// Description : An interval that calls NodePath::show().
////////////////////////////////////////////////////////////////////

255 12 WaitInterval 141313 12 WaitInterval 12 WaitInterval 0 0 0 1 238 240 0 1 239 0 1 0 241 0 0 0 0 338
////////////////////////////////////////////////////////////////////
//       Class : WaitInterval
// Description : This interval does absolutely nothing, and is mainly
//               useful for marking time between other intervals
//               within a sequence.
////////////////////////////////////////////////////////////////////

256 17 CInterval const * 8576 17 CInterval const * 17 CInterval const * 0 0 257 0 0 0 0 0 0 0 0 0

257 15 CInterval const 8832 15 CInterval const 15 CInterval const 0 0 241 0 0 0 0 0 0 0 0 0

258 13 atomic string 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0

259 6 double 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0

260 4 bool 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0

261 11 CInterval * 8576 11 CInterval * 11 CInterval * 0 0 241 0 0 0 0 0 0 0 0 0

262 4 void 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0

263 18 CIntervalManager * 8576 18 CIntervalManager * 18 CIntervalManager * 0 0 245 0 0 0 0 0 0 0 0 0

264 9 ostream * 8576 9 ostream * 9 ostream * 0 0 265 0 0 0 0 0 0 0 0 0

265 7 ostream 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0

266 3 int 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0

267 10 TypeHandle 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 1098
////////////////////////////////////////////////////////////////////
//       Class : TypeHandle
// Description : TypeHandle is the identifier used to differentiate
//               C++ class types.  Any C++ classes that inherit from
//               some base class, and must be differentiated at run
//               time, should store a static TypeHandle object that
//               can be queried through a static member function
//               named get_class_type().  Most of the time, it is also
//               desirable to inherit from TypedObject, which provides
//               some virtual functions to return the TypeHandle for a
//               particular instance.
//
//               At its essence, a TypeHandle is simply a unique
//               identifier that is assigned by the TypeRegistry.  The
//               TypeRegistry stores a tree of TypeHandles, so that
//               ancestry of a particular type may be queried, and the
//               type name may be retrieved for run-time display.
////////////////////////////////////////////////////////////////////

268 12 TypeHandle * 8576 12 TypeHandle * 12 TypeHandle * 0 0 267 0 0 0 0 0 0 0 0 0

269 12 EventQueue * 8576 12 EventQueue * 12 EventQueue * 0 0 270 0 0 0 0 0 0 0 0 0

270 10 EventQueue 2048 10 EventQueue 10 EventQueue 0 0 0 0 0 0 0 0 0 0 0 392
////////////////////////////////////////////////////////////////////
//       Class : EventQueue
// Description : A queue of pending events.  As events are thrown,
//               they are added to this queue; eventually, they will
//               be extracted out again by an EventHandler and
//               processed.
////////////////////////////////////////////////////////////////////

271 24 CIntervalManager const * 8576 24 CIntervalManager const * 24 CIntervalManager const * 0 0 272 0 0 0 0 0 0 0 0 0

272 22 CIntervalManager const 8832 22 CIntervalManager const 22 CIntervalManager const 0 0 245 0 0 0 0 0 0 0 0 0

273 21 CLerpInterval const * 8576 21 CLerpInterval const * 21 CLerpInterval const * 0 0 274 0 0 0 0 0 0 0 0 0

274 19 CLerpInterval const 8832 19 CLerpInterval const 19 CLerpInterval const 0 0 246 0 0 0 0 0 0 0 0 0

275 25 CLerpAnimEffectInterval * 8576 25 CLerpAnimEffectInterval * 25 CLerpAnimEffectInterval * 0 0 248 0 0 0 0 0 0 0 0 0

276 13 AnimControl * 8576 13 AnimControl * 13 AnimControl * 0 0 277 0 0 0 0 0 0 0 0 0

277 11 AnimControl 2048 11 AnimControl 11 AnimControl 0 0 0 0 0 0 0 0 0 0 0 487
////////////////////////////////////////////////////////////////////
//       Class : AnimControl
// Description : Controls the timing of a character animation.  An
//               AnimControl object is created for each
//               character/bundle binding and manages the state of the
//               animation: whether started, stopped, or looping, and
//               the current frame number and play rate.
////////////////////////////////////////////////////////////////////

278 5 float 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0

279 16 NodePath const * 8576 16 NodePath const * 16 NodePath const * 0 0 280 0 0 0 0 0 0 0 0 0

280 14 NodePath const 8832 14 NodePath const 14 NodePath const 0 0 281 0 0 0 0 0 0 0 0 0

281 8 NodePath 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 4938
//
// A NodePath is the fundamental unit of high-level interaction with
// the scene graph.  It encapsulates the complete path down to a node
// from some other node, usually the root of the scene graph.  This is
// used to resolve ambiguities associated with instancing.
//
// NodePath also contains a number of handy high-level methods for
// common scene-graph manipulations, such as reparenting, and common
// state changes, such as repositioning.
//
// There are also a number of NodePath methods for finding nodes deep
// within the tree by name or by type.  These take a path string,
// which at its simplest consists of a series of node names separated
// by slashes, like a directory pathname.
//
// Each component of the path string may optionally consist of one of
// the following special names, instead of a node name:
//
//   *          -- matches exactly one node, with any name.
//   **         -- matches any sequence of zero or more nodes.
//   +typename  -- matches any node that is or derives from the given type.
//   -typename  -- matches any node that is the given type exactly.
//   =tag       -- matches any node that has the indicated tag.
//   =tag=value -- matches any node whose tag matches the indicated value.
//
// Furthermore, a node name may itself contain standard filename
// globbing characters, like *, ?, and [a-z], that will be accepted as
// a partial match.  (In fact, the '*' special name may be seen as
// just a special case of this.)  The globbing characters may not be
// used with the typename matches or with tag matches, but they may
// be used to match a tag's value in the =tag=value syntax.
//
// The special characters "@@", appearing at the beginning of a node
// name, indicate a stashed node.  Normally, stashed nodes are not
// returned by a find (but see the special flags, below), but a
// stashed node may be found if it is explicitly named with its
// leading @@ characters.  By extension, "@@*" may be used to identify
// any stashed node.
//
// Examples:
//
// "room//graph" will look for a node named "graph", which is a child
// of an unnamed node, which is a child of a node named "room", which
// is a child of the starting path.
//
// "**/red*" will look for any node anywhere in the tree (below the
// starting path) with a name that begins with "red".
//
// "**/+PartBundleNode/**/head" will look for a node named "head",
// somewhere below a PartBundleNode anywhere in the tree.
//
//
// The search is always potentially ambiguous, even if the special
// wildcard operators are not used, because there may be multiple
// nodes in the tree with the same name.  In general, in the case of
// an ambiguity, the shortest path is preferred; when a method (such
// as extend_by) must choose only only one of several possible paths,
// it will choose the shortest available; on the other hand, when a
// method (such as find_all_matches) is to return all of the matching
// paths, it will sort them so that the shortest paths appear first in
// the output.
//
//
// Special flags.  The entire string may optionally be followed by the
// ";" character, followed by one or more of the following special
// control flags, with no intervening spaces or punctuation:
//
//    -h    Do not return hidden nodes.
//    +h    Do return hidden nodes.
//    -s    Do not return stashed nodes unless explicitly referenced with @@.
//    +s    Return stashed nodes even without any explicit @@ characters.
//    -i    Node name comparisons are not case insensitive: case must match
//          exactly.
//    +i    Node name comparisons are case insensitive: case is not important.
//          This affects matches against the node name only; node type
//          and tag strings are always case sensitive.
//
// The default flags are +h-s-i.
//
////////////////////////////////////////////////////////////////////
//       Class : NodePath
// Description : NodePath is the fundamental system for disambiguating
//               instances, and also provides a higher-level interface
//               for manipulating the scene graph.
//
//               A NodePath is a list of connected nodes from the root
//               of the graph to any sub-node.  Each NodePath
//               therefore uniquely describes one instance of a node.
//
//               NodePaths themselves are lightweight objects that may
//               easily be copied and passed by value.  Their data is
//               stored as a series of NodePathComponents that are
//               stored on the nodes.  Holding a NodePath will keep a
//               reference count to all the nodes in the path.
//               However, if any node in the path is removed or
//               reparented (perhaps through a different NodePath),
//               the NodePath will automatically be updated to reflect
//               the changes.
////////////////////////////////////////////////////////////////////

282 23 CLerpNodePathInterval * 8576 23 CLerpNodePathInterval * 23 CLerpNodePathInterval * 0 0 249 0 0 0 0 0 0 0 0 0

283 29 CLerpNodePathInterval const * 8576 29 CLerpNodePathInterval const * 29 CLerpNodePathInterval const * 0 0 284 0 0 0 0 0 0 0 0 0

284 27 CLerpNodePathInterval const 8832 27 CLerpNodePathInterval const 27 CLerpNodePathInterval const 0 0 249 0 0 0 0 0 0 0 0 0

285 18 LVecBase3f const * 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 286 0 0 0 0 0 0 0 0 0

286 16 LVecBase3f const 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 287 0 0 0 0 0 0 0 0 0

287 9 RGBColorf 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 942
// Filename: lvecBase3_src.h
// Created by:  drose (08Mar00)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) 2001 - 2004, Disney Enterprises, Inc.  All rights reserved
//
// All use of this software is subject to the terms of the Panda 3d
// Software license.  You should have received a copy of this license
// along with this source code; you will also find a current copy of
// the license at http://etc.cmu.edu/panda3d/docs/license/ .
//
// To contact the maintainers of this program write to
// panda3d-general@lists.sourceforge.net .
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

288 20 LQuaternionf const * 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 289 0 0 0 0 0 0 0 0 0

289 18 LQuaternionf const 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 290 0 0 0 0 0 0 0 0 0

290 12 LQuaternionf 2048 12 LQuaternionf 12 LQuaternionf 0 0 0 0 0 0 0 0 0 0 0 907
// Filename: lquaternion_src.h
// Created by:  frang (06Jun00)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) 2001 - 2004, Disney Enterprises, Inc.  All rights reserved
//
// All use of this software is subject to the terms of the Panda 3d
// Software license.  You should have received a copy of this license
// along with this source code; you will also find a current copy of
// the license at http://etc.cmu.edu/panda3d/docs/license/ .
//
// To contact the maintainers of this program write to
// panda3d-general@lists.sourceforge.net .
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//       Class : FLOATNAME(LQuaternion)
// Description : This is the base quaternion class
////////////////////////////////////////////////////////////////////

291 18 LVecBase4f const * 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 292 0 0 0 0 0 0 0 0 0

292 16 LVecBase4f const 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 293 0 0 0 0 0 0 0 0 0

293 6 Colorf 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 942
// Filename: lvecBase4_src.h
// Created by:  drose (08Mar00)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) 2001 - 2004, Disney Enterprises, Inc.  All rights reserved
//
// All use of this software is subject to the terms of the Panda 3d
// Software license.  You should have received a copy of this license
// along with this source code; you will also find a current copy of
// the license at http://etc.cmu.edu/panda3d/docs/license/ .
//
// To contact the maintainers of this program write to
// panda3d-general@lists.sourceforge.net .
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

294 15 CMetaInterval * 8576 15 CMetaInterval * 15 CMetaInterval * 0 0 250 0 0 0 0 0 0 0 0 0

295 21 CMetaInterval const * 8576 21 CMetaInterval const * 21 CMetaInterval const * 0 0 296 0 0 0 0 0 0 0 0 0

296 19 CMetaInterval const 8832 19 CMetaInterval const 19 CMetaInterval const 0 0 250 0 0 0 0 0 0 0 0 0

297 14 HideInterval * 8576 14 HideInterval * 14 HideInterval * 0 0 253 0 0 0 0 0 0 0 0 0

298 14 ShowInterval * 8576 14 ShowInterval * 14 ShowInterval * 0 0 254 0 0 0 0 0 0 0 0 0

299 14 WaitInterval * 8576 14 WaitInterval * 14 WaitInterval * 0 0 255 0 0 0 0 0 0 0 0 0

0
0
